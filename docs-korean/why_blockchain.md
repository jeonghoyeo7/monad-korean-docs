## 왜 블록체인인가

## 블록체인

블록체인은 다양한 참가자들 간의 두 가지 사항에 대한 분산된 합의입니다:

1. 거래의 공식적인 순서 (원장)
2. 계정 잔액과 다양한 프로그램의 상태를 포함한 세계의 공식적인 상태

현대의 블록체인(예: 이더리움)에서는 거래가 잔액 이체, 새로운 프로그램 생성, 기존 프로그램에 대한 함수 호출로 구성됩니다. 지금까지의 모든 거래의 종합 결과는 현재 상태를 생성합니다. 따라서 *거래 순서에 대한 합의는 상태에 대한 합의를 의미합니다.*

블록체인 시스템은 동기화된 분산 노드 집합이 새로 적용할 거래 목록에 합의하는 방법을 설명하는 프로토콜 규칙을 가지고 있습니다. 귀납법은 노드를 동기화 상태로 유지합니다: 노드는 동일한 상태로 시작하고 동일한 거래를 적용하므로, 새로운 거래 목록을 적용한 후에도 일관된 상태를 유지합니다. (노드 시스템이 합의에 도달하는 방법의 세부 사항은 생략하지만, 모나드의 [합의 메커니즘](monad_bft.md)에 대한 문서를 참조하십시오.)

공유 글로벌 상태는 분산 애플리케이션(블록체인 상에서 실행되는 애플리케이션)의 개발을 가능하게 합니다. 분산 애플리케이션은 모든 사용자가 트랜잭션을 제출하여 호출할 수 있는 함수가 있는 코드와 지속적인 애플리케이션별 상태입니다. 블록체인의 각 노드는 호출된 바이트코드를 올바르게 실행할 책임이 있습니다. 

## 예제 애플리케이션

분산 애플리케이션은 중앙집중식 방식으로 구현될 기능을 구현할 수 있습니다. 예를 들어, 매우 간단한 분산 애플리케이션의 예로 *가상 은행* (암호화폐에서는 일반적으로 대출 프로토콜이라고 함)이 있습니다.

실제에서 은행은 예금을 받고 이를 더 높은 이율로 대출하는 사업입니다. 은행은 높은 이율과 낮은 이율 간의 차액을 벌고, 대출자는 경제적으로 생산적인 일을 하기 위해 대출을 받고, 예금자는 이자를 받습니다. 모두가 이익을 얻습니다!

가상 은행은 네 가지 주요 메서드를 가진 애플리케이션입니다: `deposit`, `withdraw`, `borrow`, `repay`. 각 메서드의 논리는 주로 예금과 대출이 올바르게 추적되고 있는지 확인하기 위한 것입니다:

```python
class VirtualBank:
  def deposit(sender, amount):
    # 송금자로부터 금액을 은행(자신)으로 이체
    # 송금자의 잔액을 내부적으로 기록

  def withdraw(sender, amount):
    # 송금자가 충분한 예금을 가지고 있는지 확인
    # 송금자의 잔액을 내부적으로 차감
    # 금액을 은행(자신)으로부터 송금자로 이체

  def borrow(sender, amount):
    # ...

  def repay(sender, amount):
    # ...
```

이더리움 또는 모나드에서 누군가 이 가상 은행 코드를 작성하여 업로드할 수 있으며, 그러면 누구나 대출과 예금에 이를 사용할 수 있습니다. 이는 자국에서 은행 서비스를 이용하는 것보다 훨씬 더 쉽게 접근할 수 있습니다.

이 간단한 예는 분산 애플리케이션의 강력함을 보여줍니다. 다음은 몇 가지 추가적인 이점입니다:

- **오픈 API / 조합 가능성**: 분산 애플리케이션은 다른 분산 애플리케이션에서 원자적으로 호출될 수 있어 개발자가 기존 구성 요소를 쌓아 더 복잡한 기능을 구축할 수 있습니다.
- **투명성**: 애플리케이션 논리는 순수하게 코드로 표현되므로, 누구나 부작용에 대해 논리를 검토할 수 있습니다. 상태는 투명하고 감사 가능합니다; DeFi에서의 준비금 증명은 기본 설정입니다.
- **검열 저항성과 신뢰할 수 있는 중립성**: 누구나 허가 없이 네트워크에 트랜잭션을 제출하거나 애플리케이션을 업로드할 수 있습니다.
- **글로벌 도달성**: 인터넷에 접속할 수 있는 누구나 중요한 금융 서비스에 접근할 수 있습니다. 이는 은행 서비스가 부족하거나 없는 사용자에게도 해당됩니다.
